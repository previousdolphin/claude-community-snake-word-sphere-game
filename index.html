

<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Jesse's Snake Sphere</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; background: #000; 
            font-family: 'JetBrains Mono', monospace; 
            touch-action: none; 
            -webkit-user-select: none; user-select: none;
        }

```
    canvas { display: block; }

    /* ─── HUD ─── */
    #hud {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; display: flex; flex-direction: column; 
        justify-content: space-between; z-index: 5;
    }

    .top-bar {
        padding: 16px 20px 24px;
        background: linear-gradient(to bottom, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.4) 60%, transparent 100%);
    }

    .hud-row {
        display: flex; justify-content: space-between; align-items: center;
        margin-bottom: 8px;
    }

    #level-indicator {
        font-family: 'Orbitron', sans-serif;
        font-size: 11px; font-weight: 700;
        letter-spacing: 3px; text-transform: uppercase;
        padding: 4px 12px; border-radius: 20px;
        border: 1px solid var(--accent, #00ff88);
        color: var(--accent, #00ff88);
        background: rgba(0,255,136,0.08);
    }

    #score-display {
        font-family: 'Orbitron', sans-serif;
        font-size: 13px; font-weight: 700;
        color: #fff; letter-spacing: 2px;
    }

    #word-display {
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        color: #fff; font-size: 26px; letter-spacing: 10px; 
        font-weight: 900;
        text-shadow: 0 0 20px var(--accent, #00ff88), 0 0 40px rgba(0,255,136,0.3);
        padding: 8px 0;
    }

    .word-letter {
        display: inline-block; transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        min-width: 24px;
    }
    .word-letter.revealed {
        color: var(--accent, #00ff88);
        transform: scale(1.15);
        text-shadow: 0 0 15px var(--accent, #00ff88);
    }
    .word-letter.unrevealed { opacity: 0.35; }

    /* Progress pips */
    .progress-bar {
        display: flex; justify-content: center; gap: 6px; margin-top: 8px;
    }
    .pip {
        width: 8px; height: 8px; border-radius: 50%;
        border: 1.5px solid var(--accent, #00ff88);
        background: transparent;
        transition: all 0.4s ease;
    }
    .pip.filled { background: var(--accent, #00ff88); box-shadow: 0 0 8px var(--accent, #00ff88); }

    /* ─── BOTTOM CONTROLS ─── */
    .bottom-bar {
        padding: 0 20px 24px;
        display: flex; flex-direction: column; align-items: center; gap: 12px;
    }

    #solve-btn {
        pointer-events: auto;
        padding: 14px 48px;
        background: rgba(0,0,0,0.5);
        border: 1.5px solid var(--accent, #00ff88);
        color: var(--accent, #00ff88);
        font-family: 'Orbitron', sans-serif;
        font-size: 13px; font-weight: 700;
        border-radius: 30px;
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        text-transform: uppercase;
        letter-spacing: 3px;
        transition: all 0.25s ease;
        opacity: 0; transform: translateY(20px);
    }
    #solve-btn.visible { opacity: 1; transform: translateY(0); }
    #solve-btn:active { 
        background: var(--accent, #00ff88); color: #000; 
        box-shadow: 0 0 30px var(--accent-glow, rgba(0,255,136,0.4));
    }

    /* ─── JOYSTICK ─── */
    #joystick-zone {
        position: absolute; bottom: 0; left: 0; width: 100%; height: 45%;
        pointer-events: auto; z-index: 4;
    }
    #joystick-base {
        position: absolute; width: 120px; height: 120px;
        border-radius: 50%; border: 2px solid rgba(255,255,255,0.15);
        background: radial-gradient(circle, rgba(255,255,255,0.06) 0%, transparent 70%);
        transform: translate(-50%, -50%);
        display: none; pointer-events: none;
    }
    #joystick-thumb {
        position: absolute; width: 44px; height: 44px;
        border-radius: 50%; 
        background: radial-gradient(circle, rgba(255,255,255,0.5), rgba(255,255,255,0.2));
        border: 2px solid rgba(255,255,255,0.4);
        transform: translate(-50%, -50%);
        display: none; pointer-events: none;
    }

    /* ─── MODALS ─── */
    .modal-overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0);
        display: none; align-items: center; justify-content: center; 
        flex-direction: column; z-index: 20;
        transition: background 0.5s ease;
    }
    .modal-overlay.active { display: flex; }
    .modal-overlay.visible { background: rgba(0,0,0,0.88); }

    .modal-card {
        text-align: center; padding: 40px 32px;
        opacity: 0; transform: scale(0.9) translateY(20px);
        transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        max-width: 340px; width: 90%;
    }
    .modal-overlay.visible .modal-card {
        opacity: 1; transform: scale(1) translateY(0);
    }

    .modal-card h2 {
        font-family: 'Orbitron', sans-serif;
        font-size: 28px; font-weight: 900; letter-spacing: 4px;
        margin-bottom: 16px;
    }
    .modal-card p {
        color: #888; font-size: 13px; line-height: 1.8;
        margin-bottom: 28px; letter-spacing: 0.5px;
    }

    .modal-card input {
        font-family: 'Orbitron', sans-serif;
        font-size: 22px; padding: 12px 0; text-align: center; 
        text-transform: uppercase; letter-spacing: 6px;
        border: none; border-bottom: 2px solid var(--accent, #00ff88);
        background: transparent; color: #fff;
        width: 100%; margin-bottom: 24px; outline: none;
        transition: border-color 0.3s;
    }
    .modal-card input::placeholder { color: #444; letter-spacing: 4px; font-size: 14px; }

    .btn {
        display: inline-block; padding: 14px 36px;
        font-family: 'Orbitron', sans-serif;
        font-size: 12px; font-weight: 700; letter-spacing: 3px;
        text-transform: uppercase; border: none; border-radius: 30px;
        cursor: pointer; transition: all 0.25s ease;
    }
    .btn-primary {
        background: #fff; color: #000;
    }
    .btn-primary:active { transform: scale(0.95); }
    .btn-ghost {
        background: transparent; color: #666;
        border: 1px solid #333;
    }
    .btn-ghost:active { border-color: #888; color: #aaa; }

    .btn-row { display: flex; gap: 10px; justify-content: center; }

    /* Start screen */
    #start-screen h2 { color: var(--accent, #00ff88); }
    #start-screen .subtitle {
        font-family: 'Orbitron', sans-serif;
        font-size: 10px; letter-spacing: 6px; color: #555;
        margin-bottom: 32px;
    }

    /* Level complete */
    #level-complete h2 { color: var(--accent, #00ff88); }
    .stats-row {
        display: flex; justify-content: center; gap: 32px; margin-bottom: 28px;
    }
    .stat { text-align: center; }
    .stat-val { 
        font-family: 'Orbitron', sans-serif;
        font-size: 28px; font-weight: 900; color: #fff; 
    }
    .stat-label { font-size: 10px; color: #666; letter-spacing: 2px; margin-top: 4px; }

    /* Crash */
    #crash-screen h2 { color: #ff2255; }

    /* Win */
    #win-screen h2 { 
        color: #fff;
        background: linear-gradient(135deg, #00ff88, #00aaff, #ff00aa);
        -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        background-clip: text;
    }

    /* ─── COMBO POPUP ─── */
    #combo-popup {
        position: absolute; top: 50%; left: 50%;
        transform: translate(-50%, -50%) scale(0);
        font-family: 'Orbitron', sans-serif;
        font-size: 36px; font-weight: 900;
        color: var(--accent, #00ff88);
        text-shadow: 0 0 30px var(--accent, #00ff88);
        pointer-events: none; z-index: 8;
        opacity: 0; transition: none;
    }

    /* ─── SCREEN FLASH ─── */
    #screen-flash {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; z-index: 6;
        background: var(--accent, #00ff88);
        opacity: 0; transition: opacity 0.1s;
    }

    /* ─── LEVEL THEMES (CSS Custom Properties) ─── */
    :root {
        --accent: #00ff88;
        --accent-glow: rgba(0,255,136,0.4);
    }
</style>
```

</head>
<body>

```
<div id="screen-flash"></div>

<div id="hud">
    <div class="top-bar">
        <div class="hud-row">
            <div id="level-indicator">LEVEL 1</div>
            <div id="score-display">0</div>
        </div>
        <div id="word-display"></div>
        <div class="progress-bar" id="progress-bar"></div>
    </div>
    <div class="bottom-bar">
        <button id="solve-btn">SOLVE</button>
    </div>
</div>

<div id="combo-popup"></div>

<div id="joystick-zone">
    <div id="joystick-base"></div>
    <div id="joystick-thumb"></div>
</div>

<!-- ─── START SCREEN ─── -->
<div id="start-screen" class="modal-overlay active">
    <div class="modal-card">
        <h2>JESSE'S<br>SNAKE SPHERE</h2>
        <div class="subtitle">CLAUD COMMUNITY EDITION</div>
        <p>
            Drag to steer your snake across the sphere.<br>
            Eat orbs to reveal hidden letters.<br>
            Solve the word to advance through 4 levels.
        </p>
        <button class="btn btn-primary" onclick="startGame()">BEGIN</button>
    </div>
</div>

<!-- ─── SOLVE MODAL ─── -->
<div id="solve-modal" class="modal-overlay">
    <div class="modal-card">
        <h2 style="color:#fff">SOLVE</h2>
        <input type="text" id="solution-input" autocomplete="off" placeholder="ENTER WORD" maxlength="12">
        <div class="btn-row">
            <button class="btn btn-primary" onclick="checkSolution()">SUBMIT</button>
            <button class="btn btn-ghost" onclick="closeSolveModal()">BACK</button>
        </div>
    </div>
</div>

<!-- ─── CRASH SCREEN ─── -->
<div id="crash-screen" class="modal-overlay">
    <div class="modal-card">
        <h2>CRASHED</h2>
        <p>Your snake hit an obstacle.<br>The word remains unsolved.</p>
        <button class="btn btn-primary" onclick="resetLevel()">RETRY</button>
    </div>
</div>

<!-- ─── LEVEL COMPLETE ─── -->
<div id="level-complete" class="modal-overlay">
    <div class="modal-card">
        <h2>SOLVED</h2>
        <div id="solved-word" style="font-family:'Orbitron'; font-size:32px; letter-spacing:8px; color:#fff; margin-bottom:24px;"></div>
        <div class="stats-row">
            <div class="stat">
                <div class="stat-val" id="stat-score">0</div>
                <div class="stat-label">SCORE</div>
            </div>
            <div class="stat">
                <div class="stat-val" id="stat-time">0s</div>
                <div class="stat-label">TIME</div>
            </div>
        </div>
        <button class="btn btn-primary" id="next-level-btn" onclick="advanceLevel()">NEXT LEVEL</button>
    </div>
</div>

<!-- ─── WIN SCREEN ─── -->
<div id="win-screen" class="modal-overlay">
    <div class="modal-card">
        <h2>VICTORY</h2>
        <p>You conquered all 4 spheres.<br>Jesse's Snake Sphere — mastered.</p>
        <div class="stats-row">
            <div class="stat">
                <div class="stat-val" id="final-score">0</div>
                <div class="stat-label">FINAL SCORE</div>
            </div>
        </div>
        <button class="btn btn-primary" onclick="restartGame()">PLAY AGAIN</button>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
// ═══════════════════════════════════════════
//  CONFIGURATION
// ═══════════════════════════════════════════

const LEVELS = [
    { 
        word: "SNAKE", speed: 0.016, obstacles: 0, tailGrow: false,
        satellites: 0, gravityWells: 0, wormholes: 0, comet: false,
        accent: "#00ff88", accentHex: 0x00ff88, 
        fogColor: 0x001a0d, wireColor: 0x003d1f, wireOpacity: 0.25,
        bgStars: 0x001a0d, foodColor: 0xff0055
    },
    { 
        word: "PLANET", speed: 0.019, obstacles: 8, tailGrow: false,
        satellites: 0, gravityWells: 0, wormholes: 0, comet: false,
        accent: "#00ccff", accentHex: 0x00ccff,
        fogColor: 0x000d1a, wireColor: 0x003355, wireOpacity: 0.3,
        bgStars: 0x000d1a, foodColor: 0xff6600
    },
    { 
        word: "GRAVITY", speed: 0.022, obstacles: 3, tailGrow: true,
        satellites: 4, gravityWells: 3, wormholes: 0, comet: false,
        accent: "#aa55ff", accentHex: 0xaa55ff,
        fogColor: 0x0d0019, wireColor: 0x331155, wireOpacity: 0.3,
        bgStars: 0x0d0019, foodColor: 0xffcc00
    },
    { 
        word: "UNIVERSE", speed: 0.026, obstacles: 3, tailGrow: true,
        satellites: 3, gravityWells: 0, wormholes: 2, comet: true,
        accent: "#ff3366", accentHex: 0xff3366,
        fogColor: 0x1a000d, wireColor: 0x550022, wireOpacity: 0.35,
        bgStars: 0x1a000d, foodColor: 0x00ffcc
    }
];

const SPHERE_RADIUS = 10;

// ═══════════════════════════════════════════
//  STATE
// ═══════════════════════════════════════════

const state = {
    level: 0,
    score: 0,
    isPlaying: false,
    revealedIndices: [],
    tailSegments: [],
    direction: { x: 0, y: 1 },
    targetDirection: { x: 0, y: 1 },
    lastTailDropTime: 0,
    levelStartTime: 0,
    combo: 0,
    lastEatTime: 0,
    screenShake: 0,
    particles: [],
    trailParticles: [],
    // Dynamic level features
    satellites: [],      // { mesh, axis, angle, speed, orbitRadius }
    gravityWells: [],    // { group, phase, lat, lon }
    wormholes: [],       // { groupA, groupB, posA, posB }
    comet: null,         // { group, axis, angle, speed, trail[] }
    wormholeCooldown: 0,
};

// ═══════════════════════════════════════════
//  AUDIO ENGINE (Web Audio API)
// ═══════════════════════════════════════════

let audioCtx = null;

function initAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playTone(freq, duration, type = 'sine', vol = 0.15) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + duration);
}

function sfxEat() {
    const base = 440 + state.combo * 80;
    playTone(base, 0.12, 'sine', 0.12);
    setTimeout(() => playTone(base * 1.5, 0.1, 'sine', 0.08), 50);
}

function sfxCrash() {
    playTone(120, 0.4, 'sawtooth', 0.15);
    playTone(80, 0.5, 'square', 0.08);
}

function sfxSolve() {
    [523, 659, 784, 1047].forEach((f, i) => {
        setTimeout(() => playTone(f, 0.25, 'sine', 0.1), i * 100);
    });
}

function sfxWrong() {
    playTone(200, 0.2, 'square', 0.08);
    setTimeout(() => playTone(160, 0.25, 'square', 0.08), 100);
}

// ═══════════════════════════════════════════
//  THREE.JS SETUP
// ═══════════════════════════════════════════

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.025);

const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 200);
camera.position.z = 22;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.sortObjects = true;
document.body.insertBefore(renderer.domElement, document.body.firstChild);

// Lights
scene.add(new THREE.AmbientLight(0x606060));
const mainLight = new THREE.PointLight(0xffffff, 1.2, 60);
mainLight.position.set(5, 10, 20);
scene.add(mainLight);

// ── STARFIELD ──
const starGeo = new THREE.BufferGeometry();
const starCount = 1500;
const starPositions = new Float32Array(starCount * 3);
const starSizes = new Float32Array(starCount);
for (let i = 0; i < starCount; i++) {
    starPositions[i * 3]     = (Math.random() - 0.5) * 160;
    starPositions[i * 3 + 1] = (Math.random() - 0.5) * 160;
    starPositions[i * 3 + 2] = (Math.random() - 0.5) * 160;
    starSizes[i] = Math.random() * 1.5 + 0.5;
}
starGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
starGeo.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.4, transparent: true, opacity: 0.6, sizeAttenuation: true });
const stars = new THREE.Points(starGeo, starMat);
scene.add(stars);

// ── WORLD GROUP ──
const worldGroup = new THREE.Group();
scene.add(worldGroup);

// ── PATTERNED SPHERE ──
// Layer 1: Subtle solid surface with slight sheen
const occluder = new THREE.Mesh(
    new THREE.SphereGeometry(SPHERE_RADIUS - 0.12, 48, 48),
    new THREE.MeshStandardMaterial({ color: 0x080808, roughness: 0.9, metalness: 0.1 })
);
worldGroup.add(occluder);

// Layer 2: Hex/ico wireframe (the main pattern)
const sphereGeo = new THREE.IcosahedronGeometry(SPHERE_RADIUS, 3);
const sphereMat = new THREE.MeshBasicMaterial({ 
    color: 0x1a3322, wireframe: true, transparent: true, opacity: 0.22 
});
const sphereMesh = new THREE.Mesh(sphereGeo, sphereMat);
worldGroup.add(sphereMesh);

// Layer 3: Latitude lines
const latLineMat = new THREE.LineBasicMaterial({ color: 0x1a3322, transparent: true, opacity: 0.18 });
for (let lat = -60; lat <= 60; lat += 30) {
    const r = SPHERE_RADIUS * Math.cos(lat * Math.PI / 180);
    const y = SPHERE_RADIUS * Math.sin(lat * Math.PI / 180);
    const pts = [];
    for (let i = 0; i <= 64; i++) {
        const a = (i / 64) * Math.PI * 2;
        pts.push(new THREE.Vector3(Math.cos(a) * r, y, Math.sin(a) * r));
    }
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    const latLine = new THREE.Line(geo, latLineMat);
    worldGroup.add(latLine);
}

// Layer 4: Longitude lines
const lonLineMat = new THREE.LineBasicMaterial({ color: 0x1a3322, transparent: true, opacity: 0.12 });
for (let lon = 0; lon < 360; lon += 30) {
    const pts = [];
    for (let i = 0; i <= 64; i++) {
        const lat = (i / 64) * Math.PI - Math.PI / 2;
        const a = lon * Math.PI / 180;
        pts.push(new THREE.Vector3(
            SPHERE_RADIUS * Math.cos(lat) * Math.cos(a),
            SPHERE_RADIUS * Math.sin(lat),
            SPHERE_RADIUS * Math.cos(lat) * Math.sin(a)
        ));
    }
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    worldGroup.add(new THREE.Line(geo, lonLineMat));
}

// Layer 5: Equator ring (bright accent)
const eqPts = [];
for (let i = 0; i <= 128; i++) {
    const a = (i / 128) * Math.PI * 2;
    eqPts.push(new THREE.Vector3(Math.cos(a) * (SPHERE_RADIUS + 0.02), 0, Math.sin(a) * (SPHERE_RADIUS + 0.02)));
}
const equatorMat = new THREE.LineBasicMaterial({ color: 0x1a3322, transparent: true, opacity: 0.35 });
const equator = new THREE.Line(new THREE.BufferGeometry().setFromPoints(eqPts), equatorMat);
worldGroup.add(equator);

// Layer 6: Polar cap dots
const dotGeo = new THREE.SphereGeometry(0.12, 6, 6);
const dotMat = new THREE.MeshBasicMaterial({ color: 0x1a3322, transparent: true, opacity: 0.3 });
[1, -1].forEach(sign => {
    const dot = new THREE.Mesh(dotGeo, dotMat);
    dot.position.set(0, sign * SPHERE_RADIUS, 0);
    worldGroup.add(dot);
    // Small ring around pole
    const ringPts = [];
    const ringR = SPHERE_RADIUS * Math.cos(75 * Math.PI / 180);
    const ringY = SPHERE_RADIUS * Math.sin(75 * Math.PI / 180) * sign;
    for (let i = 0; i <= 32; i++) {
        const a = (i / 32) * Math.PI * 2;
        ringPts.push(new THREE.Vector3(Math.cos(a) * ringR, ringY, Math.sin(a) * ringR));
    }
    worldGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(ringPts), latLineMat));
});

// ── SNAKE HEAD ──
const headGroup = new THREE.Group();
// Core
const headCore = new THREE.Mesh(
    new THREE.BoxGeometry(0.75, 0.75, 0.75),
    new THREE.MeshBasicMaterial({ color: 0x00ff88 })
);
headGroup.add(headCore);
// Glow shell
const headGlow = new THREE.Mesh(
    new THREE.BoxGeometry(1.1, 1.1, 1.1),
    new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.15 })
);
headGroup.add(headGlow);
// Eyes (two small white cubes)
const eyeGeo = new THREE.BoxGeometry(0.15, 0.15, 0.15);
const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
eyeL.position.set(-0.2, 0.15, 0.38);
headGroup.add(eyeL);
const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
eyeR.position.set(0.2, 0.15, 0.38);
headGroup.add(eyeR);

headGroup.position.set(0, 0, SPHERE_RADIUS);
scene.add(headGroup);

// ── FOOD ──
const foodGroup = new THREE.Group();
worldGroup.add(foodGroup);
const foodCore = new THREE.Mesh(
    new THREE.OctahedronGeometry(0.5, 1),
    new THREE.MeshBasicMaterial({ color: 0xff0055 })
);
foodGroup.add(foodCore);
const foodGlow = new THREE.Mesh(
    new THREE.OctahedronGeometry(0.85, 1),
    new THREE.MeshBasicMaterial({ color: 0xff0055, transparent: true, opacity: 0.2 })
);
foodGroup.add(foodGlow);
const foodOrbit = new THREE.Mesh(
    new THREE.RingGeometry(0.9, 1.0, 16),
    new THREE.MeshBasicMaterial({ color: 0xff0055, transparent: true, opacity: 0.15, side: THREE.DoubleSide })
);
foodGroup.add(foodOrbit);

// ── NECK CONNECTOR (head to body) ──
const neckGeo = new THREE.CylinderGeometry(0.2, 0.2, 1, 6);
const neckMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.5 });
const neckMesh = new THREE.Mesh(neckGeo, neckMat);
neckMesh.visible = false;
scene.add(neckMesh); // In scene space since head is in scene space

// ── TAIL & OBSTACLES ──
const tailGroup = new THREE.Group();
worldGroup.add(tailGroup);
const obstacleGroup = new THREE.Group();
worldGroup.add(obstacleGroup);

// ── DYNAMIC HAZARDS ──
const satelliteGroup = new THREE.Group();
worldGroup.add(satelliteGroup);
const gravityWellGroup = new THREE.Group();
worldGroup.add(gravityWellGroup);
const wormholeGroup = new THREE.Group();
worldGroup.add(wormholeGroup);
const cometGroup = new THREE.Group();
worldGroup.add(cometGroup);

// ── PARTICLES ──
const particleGroup = new THREE.Group();
scene.add(particleGroup);

// Reusable geometries
const tailSegGeo = new THREE.SphereGeometry(0.35, 8, 6);
const connectorGeo = new THREE.CylinderGeometry(0.18, 0.18, 1, 6);
const particleGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
const obstacleGeo = new THREE.BoxGeometry(1.1, 1.1, 1.1);

// ═══════════════════════════════════════════
//  GAME LOGIC
// ═══════════════════════════════════════════

function config() { return LEVELS[state.level]; }

function applyTheme() {
    const c = config();
    document.documentElement.style.setProperty('--accent', c.accent);
    document.documentElement.style.setProperty('--accent-glow', c.accent + '66');
    scene.fog.color.setHex(c.fogColor);
    // Sphere pattern layers
    sphereMat.color.setHex(c.wireColor);
    sphereMat.opacity = c.wireOpacity;
    latLineMat.color.setHex(c.wireColor);
    lonLineMat.color.setHex(c.wireColor);
    equatorMat.color.setHex(c.accentHex);
    equatorMat.opacity = 0.4;
    dotMat.color.setHex(c.wireColor);
    // Snake & food
    headCore.material.color.setHex(c.accentHex);
    headGlow.material.color.setHex(c.accentHex);
    foodCore.material.color.setHex(c.foodColor);
    foodGlow.material.color.setHex(c.foodColor);
    foodOrbit.material.color.setHex(c.foodColor);
}

function initLevel() {
    const c = config();
    state.revealedIndices = [];
    state.tailSegments = [];
    state.direction = { x: 0, y: 1 };
    state.targetDirection = { x: 0, y: 1 };
    state.lastTailDropTime = 0;
    state.combo = 0;
    state.lastEatTime = 0;
    state.screenShake = 0;
    state.levelStartTime = performance.now();

    // Clear scene objects
    clearGroup(tailGroup);
    clearGroup(obstacleGroup);
    clearGroup(particleGroup);
    clearGroup(satelliteGroup);
    clearGroup(gravityWellGroup);
    clearGroup(wormholeGroup);
    clearGroup(cometGroup);
    state.particles = [];
    state.satellites = [];
    state.gravityWells = [];
    state.wormholes = [];
    state.comet = null;
    state.wormholeCooldown = 0;

    worldGroup.rotation.set(0, 0, 0);
    worldGroup.quaternion.identity();
    neckMesh.visible = false;

    applyTheme();
    updateHUD();
    buildProgressPips();

    // Static obstacles
    if (c.obstacles > 0) spawnObstacles(c.obstacles);
    
    // Level 3+: Orbiting satellites
    if (c.satellites > 0) spawnSatellites(c.satellites);
    
    // Level 3: Gravity wells
    if (c.gravityWells > 0) spawnGravityWells(c.gravityWells);
    
    // Level 4: Wormhole portals
    if (c.wormholes > 0) spawnWormholes(c.wormholes);
    
    // Level 4: Comet
    if (c.comet) spawnComet();

    spawnFood();

    // Show solve button after delay
    const btn = document.getElementById('solve-btn');
    btn.classList.remove('visible');
    setTimeout(() => btn.classList.add('visible'), 600);

    state.isPlaying = true;
}

function clearGroup(group) {
    while (group.children.length) {
        const c = group.children[0];
        if (c.children && c.children.length) clearGroup(c);
        group.remove(c);
        if (c.geometry) c.geometry.dispose();
        if (c.material) c.material.dispose();
    }
}

function spawnObstacles(count) {
    const mat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.8 });
    const edgeMat = new THREE.MeshBasicMaterial({ color: 0x666666, wireframe: true, transparent: true, opacity: 0.3 });
    
    for (let i = 0; i < count; i++) {
        const pos = randomOnSphere(SPHERE_RADIUS + 0.3);
        if (pos.distanceTo(new THREE.Vector3(0, 0, SPHERE_RADIUS)) < 5) { i--; continue; }
        
        const g = new THREE.Group();
        g.add(new THREE.Mesh(obstacleGeo, mat));
        g.add(new THREE.Mesh(new THREE.BoxGeometry(1.3, 1.3, 1.3), edgeMat));
        g.position.copy(pos);
        g.lookAt(0, 0, 0);
        obstacleGroup.add(g);
    }
}

function spawnFood() {
    let pos;
    let attempts = 0;
    do {
        pos = randomOnSphere(SPHERE_RADIUS + 0.4);
        attempts++;
    } while (pos.distanceTo(new THREE.Vector3(0, 0, SPHERE_RADIUS)) < 3 && attempts < 50);
    
    foodGroup.position.copy(pos);
    foodGroup.lookAt(0, 0, 0);
}

function randomOnSphere(radius) {
    const u = Math.random(), v = Math.random();
    const theta = 2 * Math.PI * u;
    const phi = Math.acos(2 * v - 1);
    return new THREE.Vector3(
        radius * Math.sin(phi) * Math.cos(theta),
        radius * Math.sin(phi) * Math.sin(theta),
        radius * Math.cos(phi)
    );
}

// ═══════════════════════════════════════════
//  LEVEL 3: ORBITING SATELLITES
// ═══════════════════════════════════════════

function spawnSatellites(count) {
    state.satellites = [];
    const c = config();
    for (let i = 0; i < count; i++) {
        const g = new THREE.Group();
        
        // Glowing orb core
        const core = new THREE.Mesh(
            new THREE.OctahedronGeometry(0.55, 0),
            new THREE.MeshBasicMaterial({ color: 0xff4444 })
        );
        g.add(core);
        
        // Pulsing danger ring
        const ring = new THREE.Mesh(
            new THREE.TorusGeometry(0.8, 0.08, 8, 16),
            new THREE.MeshBasicMaterial({ color: 0xff4444, transparent: true, opacity: 0.4 })
        );
        g.add(ring);
        
        // Outer warning glow
        const glow = new THREE.Mesh(
            new THREE.SphereGeometry(1.0, 8, 8),
            new THREE.MeshBasicMaterial({ color: 0xff2222, transparent: true, opacity: 0.12 })
        );
        g.add(glow);

        // Each satellite orbits on a random great circle
        const axis = new THREE.Vector3(
            Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5
        ).normalize();
        const angle = Math.random() * Math.PI * 2;
        const speed = 0.3 + Math.random() * 0.25; // radians per second
        const orbitRadius = SPHERE_RADIUS + 0.5;

        // Set initial position
        const pos = new THREE.Vector3(orbitRadius, 0, 0)
            .applyAxisAngle(axis, angle);
        g.position.copy(pos);

        satelliteGroup.add(g);
        state.satellites.push({ group: g, axis, angle, speed, orbitRadius, core, ring });
    }
}

function updateSatellites(delta) {
    state.satellites.forEach(sat => {
        sat.angle += sat.speed * delta;
        const pos = new THREE.Vector3(sat.orbitRadius, 0, 0)
            .applyAxisAngle(sat.axis, sat.angle);
        sat.group.position.copy(pos);
        sat.group.lookAt(0, 0, 0);
        
        // Spin the core
        sat.core.rotation.y += delta * 3;
        sat.ring.rotation.x += delta * 2;
    });
}

// ═══════════════════════════════════════════
//  LEVEL 3: GRAVITY WELLS (pulsing hazard zones)
// ═══════════════════════════════════════════

function spawnGravityWells(count) {
    state.gravityWells = [];
    for (let i = 0; i < count; i++) {
        const g = new THREE.Group();
        const pos = randomOnSphere(SPHERE_RADIUS + 0.05);
        // Don't place near start
        if (pos.distanceTo(new THREE.Vector3(0, 0, SPHERE_RADIUS)) < 5) { i--; continue; }
        g.position.copy(pos);
        g.lookAt(0, 0, 0);

        // Concentric warning rings
        const ringColors = [0xaa55ff, 0x8833dd, 0x6622aa];
        const rings = [];
        for (let r = 0; r < 3; r++) {
            const ringMesh = new THREE.Mesh(
                new THREE.TorusGeometry(0.8 + r * 0.7, 0.06, 8, 32),
                new THREE.MeshBasicMaterial({ 
                    color: ringColors[r], transparent: true, opacity: 0.0, 
                    side: THREE.DoubleSide 
                })
            );
            g.add(ringMesh);
            rings.push(ringMesh);
        }

        // Central danger core (only visible when active)
        const wellCore = new THREE.Mesh(
            new THREE.SphereGeometry(0.6, 12, 12),
            new THREE.MeshBasicMaterial({ color: 0xaa55ff, transparent: true, opacity: 0.0 })
        );
        g.add(wellCore);

        gravityWellGroup.add(g);
        
        // Each well has its own phase offset so they pulse at different times
        const phase = Math.random() * Math.PI * 2;
        state.gravityWells.push({ group: g, rings, core: wellCore, phase, active: false });
    }
}

function updateGravityWells(now, delta) {
    state.gravityWells.forEach(well => {
        // Pulsing cycle: ~4 seconds period
        // Active for ~1.2s, warning ramp for ~1s, off for ~1.8s
        const cycle = 4.0;
        const t = ((now * 0.001 + well.phase) % cycle) / cycle; // 0..1
        
        let dangerAmount = 0;
        if (t < 0.25) {
            // Warning ramp-up (rings fade in from outside to inside)
            const ramp = t / 0.25;
            well.rings.forEach((ring, idx) => {
                const ringProgress = Math.max(0, ramp - idx * 0.15);
                ring.material.opacity = ringProgress * 0.4;
                ring.rotation.z += delta * (1 + idx);
            });
            well.core.material.opacity = ramp * 0.1;
        } else if (t < 0.55) {
            // ACTIVE - danger zone!
            dangerAmount = 1;
            const pulse = 0.7 + Math.sin(now * 0.02) * 0.3;
            well.rings.forEach((ring, idx) => {
                ring.material.opacity = pulse * 0.6;
                ring.scale.setScalar(1 + Math.sin(now * 0.008 + idx) * 0.1);
                ring.rotation.z += delta * (3 + idx * 2);
            });
            well.core.material.opacity = pulse * 0.7;
            well.core.scale.setScalar(1 + Math.sin(now * 0.01) * 0.2);
        } else {
            // Off - fade out
            const fade = Math.max(0, 1 - (t - 0.55) / 0.2);
            well.rings.forEach(ring => {
                ring.material.opacity = fade * 0.3;
            });
            well.core.material.opacity = fade * 0.3;
        }
        
        well.active = dangerAmount > 0.5;
    });
}

// ═══════════════════════════════════════════
//  LEVEL 4: WORMHOLE PORTALS
// ═══════════════════════════════════════════

function spawnWormholes(count) {
    state.wormholes = [];
    state.wormholeCooldown = 0;
    
    const portalColors = [0x00ffcc, 0xff66aa];
    
    for (let i = 0; i < count; i++) {
        // Generate two positions far apart
        let posA, posB;
        do {
            posA = randomOnSphere(SPHERE_RADIUS + 0.1);
            posB = randomOnSphere(SPHERE_RADIUS + 0.1);
        } while (
            posA.distanceTo(posB) < SPHERE_RADIUS ||
            posA.distanceTo(new THREE.Vector3(0, 0, SPHERE_RADIUS)) < 4 ||
            posB.distanceTo(new THREE.Vector3(0, 0, SPHERE_RADIUS)) < 4
        );

        const color = portalColors[i % portalColors.length];

        const groupA = createPortalVisual(posA, color);
        const groupB = createPortalVisual(posB, color);
        
        wormholeGroup.add(groupA);
        wormholeGroup.add(groupB);

        state.wormholes.push({ groupA, groupB, posA: posA.clone(), posB: posB.clone(), color });
    }
}

function createPortalVisual(pos, color) {
    const g = new THREE.Group();
    g.position.copy(pos);
    g.lookAt(0, 0, 0);

    // Outer ring
    const outerRing = new THREE.Mesh(
        new THREE.TorusGeometry(1.2, 0.1, 8, 24),
        new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.7 })
    );
    g.add(outerRing);

    // Inner ring (counter-rotating)
    const innerRing = new THREE.Mesh(
        new THREE.TorusGeometry(0.8, 0.08, 8, 20),
        new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.5 })
    );
    g.add(innerRing);

    // Core glow disc
    const disc = new THREE.Mesh(
        new THREE.CircleGeometry(0.7, 16),
        new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.15, side: THREE.DoubleSide })
    );
    g.add(disc);

    // Beacon pillar (visible from far away)
    const beacon = new THREE.Mesh(
        new THREE.CylinderGeometry(0.04, 0.04, 3, 4),
        new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.3 })
    );
    beacon.position.y = 1.5;
    beacon.rotation.x = Math.PI / 2;
    g.add(beacon);

    g.userData = { outerRing, innerRing, disc };
    return g;
}

function updateWormholes(now, delta) {
    if (state.wormholeCooldown > 0) state.wormholeCooldown -= delta;
    
    state.wormholes.forEach(wh => {
        [wh.groupA, wh.groupB].forEach((g, idx) => {
            const d = g.userData;
            d.outerRing.rotation.z += delta * 1.5 * (idx === 0 ? 1 : -1);
            d.innerRing.rotation.z -= delta * 2.5 * (idx === 0 ? 1 : -1);
            const pulse = 0.5 + Math.sin(now * 0.003 + idx * Math.PI) * 0.3;
            d.disc.material.opacity = 0.1 + pulse * 0.15;
        });
    });
}

function checkWormholeEntry(headWorldPos) {
    if (state.wormholeCooldown > 0) return;
    
    for (const wh of state.wormholes) {
        const wposA = new THREE.Vector3();
        const wposB = new THREE.Vector3();
        wh.groupA.getWorldPosition(wposA);
        wh.groupB.getWorldPosition(wposB);

        let entered = null, target = null;
        if (wposA.distanceTo(headWorldPos) < 1.4) { entered = wposA; target = wh.posB; }
        else if (wposB.distanceTo(headWorldPos) < 1.4) { entered = wposB; target = wh.posA; }
        
        if (entered && target) {
            // Teleport: rotate worldGroup so that the target position 
            // ends up at the head position (0,0,SPHERE_RADIUS)
            teleportToPosition(target);
            state.wormholeCooldown = 1.5; // seconds cooldown
            
            // Effects
            screenFlash('#ffffff', 250);
            playTone(880, 0.15, 'sine', 0.1);
            setTimeout(() => playTone(1320, 0.12, 'sine', 0.08), 80);
            showCombo('WARPED!', '#' + wh.color.toString(16).padStart(6, '0'));
            spawnParticles(headWorldPos, wh.color, 20);
            return;
        }
    }
}

function teleportToPosition(targetLocalPos) {
    // We need to rotate worldGroup so that targetLocalPos (in local space)
    // maps to the head's position in world space (0, 0, SPHERE_RADIUS)
    // 
    // Current world position of target:
    const targetWorld = targetLocalPos.clone().applyMatrix4(worldGroup.matrixWorld);
    const headPos = new THREE.Vector3(0, 0, SPHERE_RADIUS);
    
    // Compute rotation from targetWorld to headPos
    const from = targetWorld.clone().normalize();
    const to = headPos.clone().normalize();
    const q = new THREE.Quaternion().setFromUnitVectors(from, to);
    
    // Apply to worldGroup
    worldGroup.quaternion.premultiply(q);
    worldGroup.updateMatrixWorld(true);
}

// ═══════════════════════════════════════════
//  LEVEL 4: COMET (roaming hazard with trail)
// ═══════════════════════════════════════════

function spawnComet() {
    state.comet = null;
    
    const g = new THREE.Group();
    
    // Comet head - bright white/yellow
    const cometHead = new THREE.Mesh(
        new THREE.SphereGeometry(0.4, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xffffff })
    );
    g.add(cometHead);
    
    // Hot inner glow
    const innerGlow = new THREE.Mesh(
        new THREE.SphereGeometry(0.7, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xffaa33, transparent: true, opacity: 0.35 })
    );
    g.add(innerGlow);

    // Outer danger glow
    const outerGlow = new THREE.Mesh(
        new THREE.SphereGeometry(1.1, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.12 })
    );
    g.add(outerGlow);

    // Random great-circle orbit
    const axis = new THREE.Vector3(
        Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5
    ).normalize();
    const angle = Math.random() * Math.PI * 2;
    const speed = 0.6; // Fast!
    const orbitRadius = SPHERE_RADIUS + 0.4;

    cometGroup.add(g);
    
    state.comet = { 
        group: g, axis, angle, speed, orbitRadius,
        trail: [], lastTrailTime: 0, cometHead, innerGlow
    };
}

function updateComet(now, delta) {
    const c = state.comet;
    if (!c) return;

    c.angle += c.speed * delta;
    const pos = new THREE.Vector3(c.orbitRadius, 0, 0)
        .applyAxisAngle(c.axis, c.angle);
    c.group.position.copy(pos);
    c.group.lookAt(0, 0, 0);
    
    // Spin head
    c.cometHead.rotation.y += delta * 5;
    c.innerGlow.scale.setScalar(1 + Math.sin(now * 0.008) * 0.2);

    // Drop trail particles in world-local space
    if (now - c.lastTrailTime > 60) {
        c.lastTrailTime = now;
        const trailMesh = new THREE.Mesh(
            new THREE.SphereGeometry(0.2, 4, 4),
            new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.5 })
        );
        trailMesh.position.copy(pos);
        cometGroup.add(trailMesh);
        c.trail.push({ mesh: trailMesh, time: now });
    }

    // Fade and remove old trail
    for (let i = c.trail.length - 1; i >= 0; i--) {
        const t = c.trail[i];
        const age = (now - t.time) / 1200;
        if (age > 1) {
            cometGroup.remove(t.mesh);
            t.mesh.geometry.dispose();
            t.mesh.material.dispose();
            c.trail.splice(i, 1);
        } else {
            t.mesh.material.opacity = (1 - age) * 0.4;
            t.mesh.scale.setScalar(1 - age * 0.7);
        }
    }
}

// ═══════════════════════════════════════════
//  HUD
// ═══════════════════════════════════════════

function updateHUD() {
    document.getElementById('level-indicator').textContent = `LEVEL ${state.level + 1}`;
    document.getElementById('score-display').textContent = state.score;
    updateWordDisplay();
    updatePips();
}

function updateWordDisplay() {
    const word = config().word;
    let html = '';
    for (let i = 0; i < word.length; i++) {
        const revealed = state.revealedIndices.includes(i);
        html += `<span class="word-letter ${revealed ? 'revealed' : 'unrevealed'}">${revealed ? word[i] : '_'}</span>`;
    }
    document.getElementById('word-display').innerHTML = html;
}

function buildProgressPips() {
    const bar = document.getElementById('progress-bar');
    const word = config().word;
    bar.innerHTML = '';
    for (let i = 0; i < word.length; i++) {
        const pip = document.createElement('div');
        pip.className = 'pip';
        bar.appendChild(pip);
    }
}

function updatePips() {
    const pips = document.querySelectorAll('.pip');
    pips.forEach((p, i) => {
        p.classList.toggle('filled', state.revealedIndices.includes(i));
    });
}

// ═══════════════════════════════════════════
//  PARTICLES
// ═══════════════════════════════════════════

function spawnParticles(worldPos, color, count = 12) {
    for (let i = 0; i < count; i++) {
        const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 });
        const mesh = new THREE.Mesh(particleGeo, mat);
        mesh.position.copy(worldPos);
        const vel = new THREE.Vector3(
            (Math.random() - 0.5) * 0.4,
            (Math.random() - 0.5) * 0.4,
            (Math.random() - 0.5) * 0.4
        );
        particleGroup.add(mesh);
        state.particles.push({ mesh, vel, life: 1, decay: 0.015 + Math.random() * 0.02 });
    }
}

function updateParticles() {
    for (let i = state.particles.length - 1; i >= 0; i--) {
        const p = state.particles[i];
        p.mesh.position.add(p.vel);
        p.life -= p.decay;
        p.mesh.material.opacity = Math.max(0, p.life);
        p.mesh.scale.setScalar(p.life);
        if (p.life <= 0) {
            particleGroup.remove(p.mesh);
            p.mesh.geometry.dispose();
            p.mesh.material.dispose();
            state.particles.splice(i, 1);
        }
    }
}

// ═══════════════════════════════════════════
//  EFFECTS
// ═══════════════════════════════════════════

function screenFlash(color = '#00ff88', duration = 120) {
    const el = document.getElementById('screen-flash');
    el.style.background = color;
    el.style.transition = 'none';
    el.style.opacity = '0.3';
    requestAnimationFrame(() => {
        el.style.transition = `opacity ${duration}ms ease-out`;
        el.style.opacity = '0';
    });
}

function showCombo(text, color) {
    const el = document.getElementById('combo-popup');
    el.textContent = text;
    el.style.color = color || config().accent;
    el.style.textShadow = `0 0 30px ${color || config().accent}`;
    el.style.transition = 'none';
    el.style.opacity = '1';
    el.style.transform = 'translate(-50%, -50%) scale(1)';
    requestAnimationFrame(() => {
        el.style.transition = 'all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1)';
        el.style.opacity = '0';
        el.style.transform = 'translate(-50%, -70%) scale(1.5)';
    });
}

// ═══════════════════════════════════════════
//  MODAL HELPERS
// ═══════════════════════════════════════════

function showModal(id) {
    const el = document.getElementById(id);
    el.classList.add('active');
    requestAnimationFrame(() => requestAnimationFrame(() => el.classList.add('visible')));
}

function hideModal(id) {
    const el = document.getElementById(id);
    el.classList.remove('visible');
    setTimeout(() => el.classList.remove('active'), 400);
}

// ═══════════════════════════════════════════
//  MAIN LOOP
// ═══════════════════════════════════════════

const AXIS_X = new THREE.Vector3(1, 0, 0);
const AXIS_Y = new THREE.Vector3(0, 1, 0);
let lastFrameTime = performance.now();

function animate() {
    requestAnimationFrame(animate);

    const now = performance.now();
    const rawDelta = (now - lastFrameTime) / 1000;
    const delta = Math.min(rawDelta, 0.05); // Cap at 50ms to prevent spiral
    lastFrameTime = now;

    // Always render
    // Star twinkling
    stars.rotation.y += delta * 0.003;

    if (state.isPlaying) {
        const c = config();

        // Smooth direction interpolation
        const lerpSpeed = 8 * delta;
        state.direction.x += (state.targetDirection.x - state.direction.x) * lerpSpeed;
        state.direction.y += (state.targetDirection.y - state.direction.y) * lerpSpeed;

        // Normalize to prevent speed boost on diagonals
        const len = Math.sqrt(state.direction.x ** 2 + state.direction.y ** 2);
        if (len > 0.01) {
            const nx = state.direction.x / len;
            const ny = state.direction.y / len;
            worldGroup.rotateOnWorldAxis(AXIS_X, -ny * c.speed);
            worldGroup.rotateOnWorldAxis(AXIS_Y, nx * c.speed);
        }

        // Head breathing animation
        const breathe = 1 + Math.sin(now * 0.005) * 0.04;
        headGlow.scale.setScalar(breathe);

        // Food animation
        foodCore.rotation.y += delta * 2;
        foodOrbit.rotation.z += delta * 1.5;
        const foodPulse = 1 + Math.sin(now * 0.004) * 0.15;
        foodGlow.scale.setScalar(foodPulse);

        // Tail
        dropTailSegment(now);

        // Update neck connector
        if (state.tailSegments.length > 0) {
            const newest = state.tailSegments[state.tailSegments.length - 1];
            const segWorldPos = new THREE.Vector3();
            newest.mesh.getWorldPosition(segWorldPos);
            const headPos2 = headGroup.position;
            const dist = headPos2.distanceTo(segWorldPos);
            if (dist > 0.1 && dist < 4) {
                neckMesh.visible = true;
                neckMesh.position.copy(headPos2).add(segWorldPos).multiplyScalar(0.5);
                const dir = new THREE.Vector3().subVectors(segWorldPos, headPos2).normalize();
                neckMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir);
                neckMesh.scale.set(1, dist, 1);
                neckMat.color.setHex(config().accentHex);
                neckMat.opacity = 0.5;
            } else {
                neckMesh.visible = false;
            }
        } else {
            neckMesh.visible = false;
        }

        // Collision
        checkCollisions();

        // Update dynamic level features
        if (state.satellites.length > 0) updateSatellites(delta);
        if (state.gravityWells.length > 0) updateGravityWells(now, delta);
        if (state.wormholes.length > 0) updateWormholes(now, delta);
        if (state.comet) updateComet(now, delta);

        // Particles
        updateParticles();

        // Screen shake decay
        if (state.screenShake > 0) {
            state.screenShake *= 0.9;
            camera.position.x = (Math.random() - 0.5) * state.screenShake;
            camera.position.y = (Math.random() - 0.5) * state.screenShake;
            if (state.screenShake < 0.01) {
                state.screenShake = 0;
                camera.position.x = 0;
                camera.position.y = 0;
            }
        }

        // Fade and scale tail segments (body tapers toward end)
        const totalSegs = state.tailSegments.length;
        state.tailSegments.forEach((seg, idx) => {
            const age = now - seg.time;
            const ageRatio = Math.max(0, 1 - age / 5000);
            const bodyRatio = totalSegs > 1 ? idx / (totalSegs - 1) : 1; // 0=oldest, 1=newest
            
            // Taper: newest segments are bigger, oldest are smaller
            const scale = 0.5 + bodyRatio * 0.6;
            seg.mesh.scale.setScalar(scale);
            seg.mesh.material.opacity = (0.2 + bodyRatio * 0.6) * ageRatio;
            
            if (seg.connector) {
                seg.connector.material.opacity = (0.15 + bodyRatio * 0.4) * ageRatio;
            }
        });
    }

    renderer.render(scene, camera);
}

function dropTailSegment(now) {
    const interval = 100;
    if (now - state.lastTailDropTime < interval) return;
    state.lastTailDropTime = now;

    const c = config();
    // Node (rounded sphere)
    const nodeMat = new THREE.MeshBasicMaterial({ 
        color: c.accentHex, transparent: true, opacity: 0.8 
    });
    const node = new THREE.Mesh(tailSegGeo, nodeMat);
    const localPos = headGroup.position.clone();
    worldGroup.worldToLocal(localPos);
    node.position.copy(localPos);

    tailGroup.add(node);

    // Connector to previous segment
    let connector = null;
    if (state.tailSegments.length > 0) {
        const prev = state.tailSegments[state.tailSegments.length - 1];
        connector = createConnector(prev.mesh.position, localPos, c.accentHex);
        if (connector) tailGroup.add(connector);
    }

    state.tailSegments.push({ mesh: node, connector, time: now });

    const maxLen = c.tailGrow ? (8 + state.revealedIndices.length * 4) : 12;
    while (state.tailSegments.length > maxLen) {
        const old = state.tailSegments.shift();
        tailGroup.remove(old.mesh);
        old.mesh.geometry.dispose();
        old.mesh.material.dispose();
        if (old.connector) {
            tailGroup.remove(old.connector);
            old.connector.geometry.dispose();
            old.connector.material.dispose();
        }
    }
}

function createConnector(posA, posB, color) {
    const dist = posA.distanceTo(posB);
    if (dist < 0.01 || dist > 3) return null; // Skip if too far or overlapping
    
    const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.5 });
    const geo = new THREE.CylinderGeometry(0.16, 0.16, dist, 5);
    const cyl = new THREE.Mesh(geo, mat);
    
    // Position at midpoint
    cyl.position.copy(posA).add(posB).multiplyScalar(0.5);
    
    // Orient cylinder from A to B
    const dir = new THREE.Vector3().subVectors(posB, posA).normalize();
    const up = new THREE.Vector3(0, 1, 0);
    const quat = new THREE.Quaternion().setFromUnitVectors(up, dir);
    cyl.quaternion.copy(quat);
    
    return cyl;
}

function checkCollisions() {
    const headPos = headGroup.position;

    // Food
    const foodWorldPos = new THREE.Vector3();
    foodCore.getWorldPosition(foodWorldPos);
    if (foodWorldPos.distanceTo(headPos) < 1.5) eatFood();

    // Static obstacles
    for (const obs of obstacleGroup.children) {
        const p = new THREE.Vector3();
        obs.getWorldPosition(p);
        if (p.distanceTo(headPos) < 1.1) { gameOver(); return; }
    }

    // Orbiting satellites
    for (const sat of state.satellites) {
        const p = new THREE.Vector3();
        sat.group.getWorldPosition(p);
        if (p.distanceTo(headPos) < 1.2) { gameOver(); return; }
    }

    // Gravity wells (only when active)
    for (const well of state.gravityWells) {
        if (!well.active) continue;
        const p = new THREE.Vector3();
        well.group.getWorldPosition(p);
        if (p.distanceTo(headPos) < 2.0) { gameOver(); return; }
    }

    // Wormhole portals (teleport, not damage)
    if (state.wormholes.length > 0) {
        checkWormholeEntry(headPos);
    }

    // Comet
    if (state.comet) {
        const p = new THREE.Vector3();
        state.comet.group.getWorldPosition(p);
        if (p.distanceTo(headPos) < 1.3) { gameOver(); return; }
    }

    // No self-collision: snake climbs over itself on the 3D sphere
}

function eatFood() {
    const word = config().word;
    const unrevealed = [];
    for (let i = 0; i < word.length; i++) {
        if (!state.revealedIndices.includes(i)) unrevealed.push(i);
    }
    if (unrevealed.length === 0) return;

    const idx = unrevealed[Math.floor(Math.random() * unrevealed.length)];
    state.revealedIndices.push(idx);

    // Combo
    const now = performance.now();
    if (now - state.lastEatTime < 4000) {
        state.combo = Math.min(state.combo + 1, 5);
    } else {
        state.combo = 1;
    }
    state.lastEatTime = now;

    // Score
    const points = 100 * state.combo;
    state.score += points;

    // Effects
    sfxEat();
    screenFlash(config().accent, 150);
    
    const foodWorldPos = new THREE.Vector3();
    foodCore.getWorldPosition(foodWorldPos);
    spawnParticles(foodWorldPos, config().foodColor, 15);

    // Head pulse
    headCore.scale.setScalar(1.4);
    headGlow.scale.setScalar(1.8);
    setTimeout(() => { headCore.scale.setScalar(1); }, 200);

    if (state.combo > 1) {
        showCombo(`${state.combo}× COMBO  +${points}`, config().accent);
    } else {
        showCombo(`+${points}`);
    }

    updateHUD();
    spawnFood();

    // Auto-solve when all letters collected
    if (state.revealedIndices.length === word.length) {
        showCombo('SOLVED!', '#ffffff');
        state.isPlaying = false;
        sfxSolve();
        screenFlash('#ffffff', 300);

        const elapsed = Math.floor((performance.now() - state.levelStartTime) / 1000);
        const timeBonus = Math.max(0, 500 - elapsed * 5);
        state.score += timeBonus + 500;

        setTimeout(() => {
            document.getElementById('solve-btn').classList.remove('visible');
            if (state.level < LEVELS.length - 1) {
                document.getElementById('solved-word').textContent = word;
                document.getElementById('stat-score').textContent = state.score;
                document.getElementById('stat-time').textContent = `${elapsed}s`;
                document.getElementById('next-level-btn').textContent = 'NEXT LEVEL';
                showModal('level-complete');
            } else {
                document.getElementById('final-score').textContent = state.score;
                showModal('win-screen');
            }
        }, 800);
        return;
    }
}

function gameOver() {
    state.isPlaying = false;
    sfxCrash();
    state.screenShake = 1.5;
    screenFlash('#ff2255', 200);
    spawnParticles(headGroup.position.clone(), 0xff2255, 25);
    
    document.getElementById('solve-btn').classList.remove('visible');
    setTimeout(() => showModal('crash-screen'), 600);
}

// ═══════════════════════════════════════════
//  GAME FLOW
// ═══════════════════════════════════════════

function startGame() {
    initAudio();
    hideModal('start-screen');
    state.score = 0;
    state.level = 0;
    setTimeout(() => { initLevel(); }, 400);
}

function resetLevel() {
    hideModal('crash-screen');
    setTimeout(() => initLevel(), 300);
}

function advanceLevel() {
    hideModal('level-complete');
    state.level++;
    setTimeout(() => initLevel(), 400);
}

function restartGame() {
    hideModal('win-screen');
    state.level = 0;
    state.score = 0;
    setTimeout(() => initLevel(), 400);
}

// ═══════════════════════════════════════════
//  SOLVE MECHANIC
// ═══════════════════════════════════════════

document.getElementById('solve-btn').addEventListener('click', () => {
    if (!state.isPlaying) return;
    initAudio();
    state.isPlaying = false;
    showModal('solve-modal');
    const input = document.getElementById('solution-input');
    input.value = '';
    input.style.borderColor = config().accent;
    setTimeout(() => input.focus(), 500);
});

function closeSolveModal() {
    hideModal('solve-modal');
    setTimeout(() => { state.isPlaying = true; }, 400);
}

function checkSolution() {
    const attempt = document.getElementById('solution-input').value.toUpperCase().trim();
    const target = config().word;

    if (attempt === target) {
        sfxSolve();
        hideModal('solve-modal');

        const elapsed = Math.floor((performance.now() - state.levelStartTime) / 1000);
        const timeBonus = Math.max(0, 500 - elapsed * 5);
        state.score += timeBonus + 500;

        setTimeout(() => {
            document.getElementById('solved-word').textContent = target;
            document.getElementById('stat-score').textContent = state.score;
            document.getElementById('stat-time').textContent = `${elapsed}s`;

            if (state.level < LEVELS.length - 1) {
                document.getElementById('next-level-btn').textContent = 'NEXT LEVEL';
                showModal('level-complete');
            } else {
                document.getElementById('final-score').textContent = state.score;
                showModal('win-screen');
            }
        }, 300);
    } else {
        sfxWrong();
        const input = document.getElementById('solution-input');
        input.style.borderColor = '#ff2255';
        input.style.transition = 'border-color 0.15s';
        input.value = '';
        input.setAttribute('placeholder', 'WRONG — TRY AGAIN');
        setTimeout(() => {
            input.style.borderColor = config().accent;
            input.setAttribute('placeholder', 'ENTER WORD');
        }, 1200);
    }
}

document.getElementById('solution-input').addEventListener('keyup', e => {
    if (e.key === 'Enter') checkSolution();
});

// ═══════════════════════════════════════════
//  JOYSTICK INPUT
// ═══════════════════════════════════════════

const jZone = document.getElementById('joystick-zone');
const jBase = document.getElementById('joystick-base');
const jThumb = document.getElementById('joystick-thumb');

let jActive = false;
let jOrigin = { x: 0, y: 0 };
const J_RADIUS = 50;

jZone.addEventListener('touchstart', e => {
    if (!state.isPlaying) return;
    initAudio();
    e.preventDefault();
    const t = e.touches[0];
    jOrigin.x = t.clientX;
    jOrigin.y = t.clientY;
    jActive = true;

    jBase.style.left = t.clientX + 'px';
    jBase.style.top = t.clientY + 'px';
    jBase.style.display = 'block';
    jThumb.style.left = t.clientX + 'px';
    jThumb.style.top = t.clientY + 'px';
    jThumb.style.display = 'block';
}, { passive: false });

jZone.addEventListener('touchmove', e => {
    if (!jActive || !state.isPlaying) return;
    e.preventDefault();
    const t = e.touches[0];
    let dx = t.clientX - jOrigin.x;
    let dy = t.clientY - jOrigin.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    // Clamp
    if (dist > J_RADIUS) {
        dx = (dx / dist) * J_RADIUS;
        dy = (dy / dist) * J_RADIUS;
    }

    jThumb.style.left = (jOrigin.x + dx) + 'px';
    jThumb.style.top = (jOrigin.y + dy) + 'px';

    // Map to direction (deadzone)
    if (dist > 12) {
        const nx = dx / Math.max(dist, 1);
        const ny = -dy / Math.max(dist, 1); // Invert Y
        state.targetDirection.x = nx;
        state.targetDirection.y = ny;
    }
}, { passive: false });

const endJoystick = () => {
    jActive = false;
    jBase.style.display = 'none';
    jThumb.style.display = 'none';
};
jZone.addEventListener('touchend', endJoystick);
jZone.addEventListener('touchcancel', endJoystick);

// Keyboard (desktop)
const keysDown = {};
document.addEventListener('keydown', e => {
    keysDown[e.key] = true;
    updateKeyboardDirection();
});
document.addEventListener('keyup', e => {
    keysDown[e.key] = false;
    updateKeyboardDirection();
});

function updateKeyboardDirection() {
    if (!state.isPlaying) return;
    let x = 0, y = 0;
    if (keysDown['ArrowLeft'] || keysDown['a']) x += 1;
    if (keysDown['ArrowRight'] || keysDown['d']) x -= 1;
    if (keysDown['ArrowUp'] || keysDown['w']) y += 1;
    if (keysDown['ArrowDown'] || keysDown['s']) y -= 1;
    if (x !== 0 || y !== 0) {
        state.targetDirection.x = x;
        state.targetDirection.y = y;
    }
}

// ═══════════════════════════════════════════
//  RESIZE
// ═══════════════════════════════════════════

window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});

// ═══════════════════════════════════════════
//  BOOT — show start, begin render loop
// ═══════════════════════════════════════════

showModal('start-screen');
animate();

</script>
```

</body>
</html>
