<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Jesse's Snake Sphere</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { overflow: hidden; background: #000; font-family: 'JetBrains Mono', monospace; touch-action: none; -webkit-user-select: none; user-select: none; }
canvas { display: block; }
#hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; z-index: 5; }
.top-bar { padding: 16px 20px 24px; background: linear-gradient(to bottom, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.4) 60%, transparent 100%); }
.hud-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
#level-indicator { font-family: 'Orbitron', sans-serif; font-size: 11px; font-weight: 700; letter-spacing: 3px; text-transform: uppercase; padding: 4px 12px; border-radius: 20px; border: 1.5px solid var(--accent, #00ff88); color: var(--accent, #00ff88); background: rgba(0,255,136,0.08); }
#score-display { font-family: 'Orbitron', sans-serif; font-size: 13px; font-weight: 700; color: #fff; letter-spacing: 2px; }
#word-display { text-align: center; font-family: 'Orbitron', sans-serif; color: #fff; font-size: 26px; letter-spacing: 10px; font-weight: 900; text-shadow: 0 0 20px var(--accent, #00ff88), 0 0 40px rgba(0,255,136,0.3); padding: 8px 0; }
.word-letter { display: inline-block; transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); min-width: 24px; }
.word-letter.revealed { color: var(--accent, #00ff88); transform: scale(1.15); text-shadow: 0 0 15px var(--accent, #00ff88); }
.word-letter.unrevealed { opacity: 0.35; }
.progress-bar { display: flex; justify-content: center; gap: 6px; margin-top: 8px; }
.pip { width: 8px; height: 8px; border-radius: 50%; border: 1.5px solid var(--accent, #00ff88); background: transparent; transition: all 0.4s ease; }
.pip.filled { background: var(--accent, #00ff88); box-shadow: 0 0 8px var(--accent, #00ff88); }
.bottom-bar { padding: 0 20px 24px; display: flex; flex-direction: column; align-items: center; gap: 12px; }
#solve-btn { pointer-events: auto; padding: 14px 48px; background: rgba(0,0,0,0.5); border: 1.5px solid var(--accent, #00ff88); color: var(--accent, #00ff88); font-family: 'Orbitron', sans-serif; font-size: 13px; font-weight: 700; border-radius: 30px; backdrop-filter: blur(12px); text-transform: uppercase; letter-spacing: 3px; transition: all 0.25s ease; opacity: 0; transform: translateY(20px); }
#solve-btn.visible { opacity: 1; transform: translateY(0); }
#solve-btn:active { background: var(--accent, #00ff88); color: #000; box-shadow: 0 0 30px var(--accent-glow, rgba(0,255,136,0.4)); }
#joystick-zone { position: absolute; bottom: 0; left: 0; width: 100%; height: 45%; pointer-events: auto; z-index: 4; }
#joystick-base { position: absolute; width: 120px; height: 120px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.15); background: radial-gradient(circle, rgba(255,255,255,0.06) 0%, transparent 70%); transform: translate(-50%, -50%); display: none; pointer-events: none; }
#joystick-thumb { position: absolute; width: 44px; height: 44px; border-radius: 50%; background: radial-gradient(circle, rgba(255,255,255,0.5), rgba(255,255,255,0.2)); border: 2px solid rgba(255,255,255,0.4); transform: translate(-50%, -50%); display: none; pointer-events: none; }
.modal-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0); display: none; align-items: center; justify-content: center; flex-direction: column; z-index: 20; transition: background 0.5s ease; }
.modal-overlay.active { display: flex; }
.modal-overlay.visible { background: rgba(0,0,0,0.88); }
.modal-card { text-align: center; padding: 40px 32px; opacity: 0; transform: scale(0.9) translateY(20px); transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); max-width: 340px; width: 90%; }
.modal-overlay.visible .modal-card { opacity: 1; transform: scale(1) translateY(0); }
.modal-card h2 { font-family: 'Orbitron', sans-serif; font-size: 28px; font-weight: 900; letter-spacing: 4px; margin-bottom: 16px; }
.modal-card p { color: #888; font-size: 13px; line-height: 1.8; margin-bottom: 28px; letter-spacing: 0.5px; }
.modal-card input { font-family: 'Orbitron', sans-serif; font-size: 22px; padding: 12px 0; text-align: center; text-transform: uppercase; letter-spacing: 6px; border: none; border-bottom: 2px solid var(--accent, #00ff88); background: transparent; color: #fff; width: 100%; margin-bottom: 24px; outline: none; transition: border-color 0.3s; }
.modal-card input::placeholder { color: #444; letter-spacing: 4px; font-size: 14px; }
.btn { display: inline-block; padding: 14px 36px; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 700; letter-spacing: 3px; text-transform: uppercase; border: none; border-radius: 30px; cursor: pointer; transition: all 0.25s ease; }
.btn-primary { background: #fff; color: #000; }
.btn-primary:active { transform: scale(0.95); }
.btn-ghost { background: transparent; color: #666; border: 1px solid #333; }
.btn-ghost:active { border-color: #888; color: #aaa; }
.btn-row { display: flex; gap: 10px; justify-content: center; }
#start-screen h2 { color: var(--accent, #00ff88); }
#start-screen .subtitle { font-family: 'Orbitron', sans-serif; font-size: 10px; letter-spacing: 6px; color: #555; margin-bottom: 32px; }
#level-complete h2 { color: var(--accent, #00ff88); }
.stats-row { display: flex; justify-content: center; gap: 32px; margin-bottom: 28px; }
.stat { text-align: center; }
.stat-val { font-family: 'Orbitron', sans-serif; font-size: 28px; font-weight: 900; color: #fff; }
.stat-label { font-size: 10px; color: #666; letter-spacing: 2px; margin-top: 4px; }
#crash-screen h2 { color: #ff2255; }
#win-screen h2 { color: #fff; background: linear-gradient(135deg, #00ff88, #00aaff, #ff00aa); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
#combo-popup { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0); font-family: 'Orbitron', sans-serif; font-size: 36px; font-weight: 900; color: var(--accent, #00ff88); text-shadow: 0 0 30px var(--accent, #00ff88); pointer-events: none; z-index: 8; opacity: 0; transition: none; }
#screen-flash { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 6; background: var(--accent, #00ff88); opacity: 0; transition: opacity 0.1s; }
:root { --accent: #00ff88; --accent-glow: rgba(0,255,136,0.4); }
</style>
</head>
<body>
<div id="screen-flash"></div>
<div id="hud">
<div class="top-bar">
<div class="hud-row">
<div id="level-indicator">LEVEL 1</div>
<div id="score-display">0</div>
</div>
<div id="word-display"></div>
<div class="progress-bar" id="progress-bar"></div>
</div>
<div class="bottom-bar">
<button id="solve-btn">SOLVE</button>
</div>
</div>
<div id="combo-popup"></div>
<div id="joystick-zone">
<div id="joystick-base"></div>
<div id="joystick-thumb"></div>
</div>
<div id="start-screen" class="modal-overlay active">
<div class="modal-card">
<h2>JESSE'S<br>SNAKE SPHERE</h2>
<div class="subtitle">HACKATHON EDITION</div>
<p>Drag to steer your snake across the sphere.<br>Eat orbs to reveal hidden letters.<br>Solve the word to advance through 4 levels.</p>
<button class="btn btn-primary" onclick="startGame()">BEGIN</button>
</div>
</div>
<div id="solve-modal" class="modal-overlay">
<div class="modal-card">
<h2 style="color:#fff">SOLVE</h2>
<input type="text" id="solution-input" autocomplete="off" placeholder="ENTER WORD" maxlength="12">
<div class="btn-row">
<button class="btn btn-primary" onclick="checkSolution()">SUBMIT</button>
<button class="btn btn-ghost" onclick="closeSolveModal()">BACK</button>
</div>
</div>
</div>
<div id="crash-screen" class="modal-overlay">
<div class="modal-card">
<h2>CRASHED</h2>
<p>Your snake hit an obstacle.<br>The word remains unsolved.</p>
<button class="btn btn-primary" onclick="resetLevel()">RETRY</button>
</div>
</div>
<div id="level-complete" class="modal-overlay">
<div class="modal-card">
<h2>SOLVED</h2>
<div id="solved-word" style="font-family:'Orbitron'; font-size:32px; letter-spacing:8px; color:#fff; margin-bottom:24px;"></div>
<div class="stats-row">
<div class="stat">
<div class="stat-val" id="stat-score">0</div>
<div class="stat-label">SCORE</div>
</div>
<div class="stat">
<div class="stat-val" id="stat-time">0s</div>
<div class="stat-label">TIME</div>
</div>
</div>
<button class="btn btn-primary" id="next-level-btn" onclick="advanceLevel()">NEXT LEVEL</button>
</div>
</div>
<div id="win-screen" class="modal-overlay">
<div class="modal-card">
<h2>VICTORY</h2>
<p>You conquered all 4 spheres.<br>Jesse's Snake Sphere â€” mastered.</p>
<div class="stats-row">
<div class="stat">
<div class="stat-val" id="final-score">0</div>
<div class="stat-label">FINAL SCORE</div>
</div>
</div>
<button class="btn btn-primary" onclick="restartGame()">PLAY AGAIN</button>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const LEVELS = [
{ word: "SNAKE", speed: 0.016, obstacles: 0, tailGrow: false, accent: "#00ff88", accentHex: 0x00ff88, fogColor: 0x001a0d, wireColor: 0x003d1f, foodColor: 0xff0055 },
{ word: "PLANET", speed: 0.019, obstacles: 8, tailGrow: false, accent: "#00ccff", accentHex: 0x00ccff, fogColor: 0x000d1a, wireColor: 0x003355, foodColor: 0xff6600 },
{ word: "GRAVITY", speed: 0.022, obstacles: 3, tailGrow: true, accent: "#aa55ff", accentHex: 0xaa55ff, fogColor: 0x0d0019, wireColor: 0x331155, foodColor: 0xffcc00 },
{ word: "UNIVERSE", speed: 0.026, obstacles: 3, tailGrow: true, accent: "#ff3366", accentHex: 0xff3366, fogColor: 0x1a000d, wireColor: 0x550022, foodColor: 0x00ffcc }
];
const SPHERE_RADIUS = 10;
const state = { level: 0, score: 0, isPlaying: false, revealedIndices: [], tailSegments: [], direction: { x: 0, y: 1 }, targetDirection: { x: 0, y: 1 }, lastTailDropTime: 0, levelStartTime: 0, combo: 0, lastEatTime: 0, screenShake: 0, particles: [] };
let audioCtx = null;
function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); if (audioCtx.state === 'suspended') audioCtx.resume(); }
function playTone(freq, duration, type = 'sine', vol = 0.15) {
if (!audioCtx) return;
const osc = audioCtx.createOscillator();
const gain = audioCtx.createGain();
osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
gain.gain.setValueAtTime(vol, audioCtx.currentTime);
gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime + duration);
}
function sfxEat() { const base = 440 + state.combo * 80; playTone(base, 0.12, 'sine', 0.12); setTimeout(() => playTone(base * 1.5, 0.1, 'sine', 0.08), 50); }
function sfxCrash() { playTone(120, 0.4, 'sawtooth', 0.15); playTone(80, 0.5, 'square', 0.08); }
function sfxSolve() { [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => playTone(f, 0.25, 'sine', 0.1), i * 100)); }
function sfxWrong() { playTone(200, 0.2, 'square', 0.08); setTimeout(() => playTone(160, 0.25, 'square', 0.08), 100); }
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.025);
const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 200);
camera.position.z = 22;
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
document.body.insertBefore(renderer.domElement, document.body.firstChild);
scene.add(new THREE.AmbientLight(0x606060));
const mainLight = new THREE.PointLight(0xffffff, 1.2, 60);
mainLight.position.set(5, 10, 20);
scene.add(mainLight);
const starGeo = new THREE.BufferGeometry();
const starCount = 1500;
const starPositions = new Float32Array(starCount * 3);
for (let i = 0; i < starCount; i++) { starPositions[i * 3] = (Math.random() - 0.5) * 160; starPositions[i * 3 + 1] = (Math.random() - 0.5) * 160; starPositions[i * 3 + 2] = (Math.random() - 0.5) * 160; }
starGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.4, transparent: true, opacity: 0.6 }));
scene.add(stars);
const worldGroup = new THREE.Group();
scene.add(worldGroup);
const occluder = new THREE.Mesh(new THREE.SphereGeometry(SPHERE_RADIUS - 0.12, 48, 48), new THREE.MeshStandardMaterial({ color: 0x080808 }));
worldGroup.add(occluder);
const sphereGeo = new THREE.IcosahedronGeometry(SPHERE_RADIUS, 3);
const sphereMat = new THREE.MeshBasicMaterial({ color: 0x1a3322, wireframe: true, transparent: true, opacity: 0.22 });
worldGroup.add(new THREE.Mesh(sphereGeo, sphereMat));
const latLineMat = new THREE.LineBasicMaterial({ color: 0x1a3322, transparent: true, opacity: 0.18 });
for (let lat = -60; lat <= 60; lat += 30) {
const r = SPHERE_RADIUS * Math.cos(lat * Math.PI / 180);
const y = SPHERE_RADIUS * Math.sin(lat * Math.PI / 180);
const pts = [];
for (let i = 0; i <= 64; i++) { pts.push(new THREE.Vector3(Math.cos((i / 64) * Math.PI * 2) * r, y, Math.sin((i / 64) * Math.PI * 2) * r)); }
worldGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), latLineMat));
}
const lonLineMat = new THREE.LineBasicMaterial({ color: 0x1a3322, transparent: true, opacity: 0.12 });
for (let lon = 0; lon < 360; lon += 30) {
const pts = [];
for (let i = 0; i <= 64; i++) {
const lat = (i / 64) * Math.PI - Math.PI / 2;
const a = lon * Math.PI / 180;
pts.push(new THREE.Vector3(SPHERE_RADIUS * Math.cos(lat) * Math.cos(a), SPHERE_RADIUS * Math.sin(lat), SPHERE_RADIUS * Math.cos(lat) * Math.sin(a)));
}
worldGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), lonLineMat));
}
const equatorMat = new THREE.LineBasicMaterial({ color: 0x1a3322, transparent: true, opacity: 0.35 });
const eqPts = [];
for (let i = 0; i <= 128; i++) { eqPts.push(new THREE.Vector3(Math.cos((i / 128) * Math.PI * 2) * (SPHERE_RADIUS + 0.02), 0, Math.sin((i / 128) * Math.PI * 2) * (SPHERE_RADIUS + 0.02))); }
worldGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(eqPts), equatorMat));
const headGroup = new THREE.Group();
const headCore = new THREE.Mesh(new THREE.BoxGeometry(0.75, 0.75, 0.75), new THREE.MeshBasicMaterial({ color: 0x00ff88 }));
headGroup.add(headCore);
const headGlow = new THREE.Mesh(new THREE.BoxGeometry(1.1, 1.1, 1.1), new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.15 }));
headGroup.add(headGlow);
headGroup.position.set(0, 0, SPHERE_RADIUS);
scene.add(headGroup);
const foodGroup = new THREE.Group();
worldGroup.add(foodGroup);
const foodCore = new THREE.Mesh(new THREE.OctahedronGeometry(0.5, 1), new THREE.MeshBasicMaterial({ color: 0xff0055 }));
foodGroup.add(foodCore);
const foodGlow = new THREE.Mesh(new THREE.OctahedronGeometry(0.85, 1), new THREE.MeshBasicMaterial({ color: 0xff0055, transparent: true, opacity: 0.2 }));
foodGroup.add(foodGlow);
const neckMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 1, 6), new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.5 }));
neckMesh.visible = false;
scene.add(neckMesh);
const tailGroup = new THREE.Group();
worldGroup.add(tailGroup);
const obstacleGroup = new THREE.Group();
worldGroup.add(obstacleGroup);
const particleGroup = new THREE.Group();
scene.add(particleGroup);
const tailSegGeo = new THREE.SphereGeometry(0.35, 8, 6);
const particleGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
const obstacleGeo = new THREE.BoxGeometry(1.1, 1.1, 1.1);
function config() { return LEVELS[state.level]; }
function applyTheme() {
const c = config();
document.documentElement.style.setProperty('--accent', c.accent);
document.documentElement.style.setProperty('--accent-glow', c.accent + '66');
scene.fog.color.setHex(c.fogColor);
sphereMat.color.setHex(c.wireColor);
latLineMat.color.setHex(c.wireColor);
lonLineMat.color.setHex(c.wireColor);
equatorMat.color.setHex(c.accentHex);
headCore.material.color.setHex(c.accentHex);
headGlow.material.color.setHex(c.accentHex);
foodCore.material.color.setHex(c.foodColor);
foodGlow.material.color.setHex(c.foodColor);
}
function initLevel() {
const c = config();
state.revealedIndices = [];
state.tailSegments = [];
state.direction = { x: 0, y: 1 };
state.targetDirection = { x: 0, y: 1 };
state.lastTailDropTime = 0;
state.combo = 0;
state.lastEatTime = 0;
state.screenShake = 0;
state.levelStartTime = performance.now();
while (tailGroup.children.length) { tailGroup.remove(tailGroup.children[0]); }
while (obstacleGroup.children.length) { obstacleGroup.remove(obstacleGroup.children[0]); }
while (particleGroup.children.length) { particleGroup.remove(particleGroup.children[0]); }
state.particles = [];
worldGroup.rotation.set(0, 0, 0);
worldGroup.quaternion.identity();
neckMesh.visible = false;
applyTheme();
updateHUD();
buildProgressPips();
if (c.obstacles > 0) spawnObstacles(c.obstacles);
spawnFood();
const btn = document.getElementById('solve-btn');
btn.classList.remove('visible');
setTimeout(() => btn.classList.add('visible'), 600);
state.isPlaying = true;
}
function randomOnSphere(radius) {
const u = Math.random(), v = Math.random();
return new THREE.Vector3(radius * Math.sin(Math.acos(2 * v - 1)) * Math.cos(2 * Math.PI * u), radius * Math.sin(Math.acos(2 * v - 1)) * Math.sin(2 * Math.PI * u), radius * Math.cos(Math.acos(2 * v - 1)));
}
function spawnObstacles(count) {
const mat = new THREE.MeshStandardMaterial({ color: 0x444444 });
for (let i = 0; i < count; i++) {
const pos = randomOnSphere(SPHERE_RADIUS + 0.3);
if (pos.distanceTo(new THREE.Vector3(0, 0, SPHERE_RADIUS)) < 5) { i--; continue; }
const g = new THREE.Mesh(obstacleGeo, mat);
g.position.copy(pos);
g.lookAt(0, 0, 0);
obstacleGroup.add(g);
}
}
function spawnFood() {
let pos, attempts = 0;
do { pos = randomOnSphere(SPHERE_RADIUS + 0.4); attempts++; } while (pos.distanceTo(new THREE.Vector3(0, 0, SPHERE_RADIUS)) < 3 && attempts < 50);
foodGroup.position.copy(pos);
foodGroup.lookAt(0, 0, 0);
}
function updateHUD() {
document.getElementById('level-indicator').textContent = `LEVEL ${state.level + 1}`;
document.getElementById('score-display').textContent = state.score;
let html = '';
const word = config().word;
for (let i = 0; i < word.length; i++) {
html += `<span class="word-letter ${state.revealedIndices.includes(i) ? 'revealed' : 'unrevealed'}">${state.revealedIndices.includes(i) ? word[i] : '_'}</span>`;
}
document.getElementById('word-display').innerHTML = html;
const pips = document.querySelectorAll('.pip');
pips.forEach((p, i) => p.classList.toggle('filled', state.revealedIndices.includes(i)));
}
function buildProgressPips() {
const bar = document.getElementById('progress-bar');
bar.innerHTML = '';
for (let i = 0; i < config().word.length; i++) {
const pip = document.createElement('div');
pip.className = 'pip';
bar.appendChild(pip);
}
}
function spawnParticles(worldPos, color, count = 12) {
for (let i = 0; i < count; i++) {
const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 });
const mesh = new THREE.Mesh(particleGeo, mat);
mesh.position.copy(worldPos);
const vel = new THREE.Vector3((Math.random() - 0.5) * 0.4, (Math.random() - 0.5) * 0.4, (Math.random() - 0.5) * 0.4);
particleGroup.add(mesh);
state.particles.push({ mesh, vel, life: 1, decay: 0.015 + Math.random() * 0.02 });
}
}
function screenFlash(color = '#00ff88', duration = 120) {
const el = document.getElementById('screen-flash');
el.style.background = color;
el.style.transition = 'none';
el.style.opacity = '0.3';
requestAnimationFrame(() => { el.style.transition = `opacity ${duration}ms ease-out`; el.style.opacity = '0'; });
}
function showCombo(text, color) {
const el = document.getElementById('combo-popup');
el.textContent = text;
el.style.color = color || config().accent;
el.style.textShadow = `0 0 30px ${color || config().accent}`;
el.style.transition = 'none';
el.style.opacity = '1';
el.style.transform = 'translate(-50%, -50%) scale(1)';
requestAnimationFrame(() => { el.style.transition = 'all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1)'; el.style.opacity = '0'; el.style.transform = 'translate(-50%, -70%) scale(1.5)'; });
}
function showModal(id) {
const el = document.getElementById(id);
el.classList.add('active');
requestAnimationFrame(() => requestAnimationFrame(() => el.classList.add('visible')));
}
function hideModal(id) {
const el = document.getElementById(id);
el.classList.remove('visible');
setTimeout(() => el.classList.remove('active'), 400);
}
const AXIS_X = new THREE.Vector3(1, 0, 0);
const AXIS_Y = new THREE.Vector3(0, 1, 0);
let lastFrameTime = performance.now();
function animate() {
requestAnimationFrame(animate);
const now = performance.now();
const rawDelta = (now - lastFrameTime) / 1000;
const delta = Math.min(rawDelta, 0.05);
lastFrameTime = now;
stars.rotation.y += delta * 0.003;
if (state.isPlaying) {
const c = config();
const lerpSpeed = 8 * delta;
state.direction.x += (state.targetDirection.x - state.direction.x) * lerpSpeed;
state.direction.y += (state.targetDirection.y - state.direction.y) * lerpSpeed;
const len = Math.sqrt(state.direction.x ** 2 + state.direction.y ** 2);
if (len > 0.01) {
const nx = state.direction.x / len;
const ny = state.direction.y / len;
worldGroup.rotateOnWorldAxis(AXIS_X, -ny * c.speed);
worldGroup.rotateOnWorldAxis(AXIS_Y, nx * c.speed);
}
headGlow.scale.setScalar(1 + Math.sin(now * 0.005) * 0.04);
foodCore.rotation.y += delta * 2;
foodGlow.scale.setScalar(1 + Math.sin(now * 0.004) * 0.15);
dropTailSegment(now);
if (state.tailSegments.length > 0) {
const newest = state.tailSegments[state.tailSegments.length - 1];
const segWorldPos = new THREE.Vector3();
newest.mesh.getWorldPosition(segWorldPos);
const headPos2 = headGroup.position;
const dist = headPos2.distanceTo(segWorldPos);
if (dist > 0.1 && dist < 4) {
neckMesh.visible = true;
neckMesh.position.copy(headPos2).add(segWorldPos).multiplyScalar(0.5);
const dir = new THREE.Vector3().subVectors(segWorldPos, headPos2).normalize();
neckMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir);
neckMesh.scale.set(1, dist, 1);
neckMat.color.setHex(config().accentHex);
neckMat.opacity = 0.5;
} else { neckMesh.visible = false; }
} else { neckMesh.visible = false; }
checkCollisions();
for (let i = state.particles.length - 1; i >= 0; i--) {
const p = state.particles[i];
p.mesh.position.add(p.vel);
p.life -= p.decay;
p.mesh.material.opacity = Math.max(0, p.life);
p.mesh.scale.setScalar(p.life);
if (p.life <= 0) { particleGroup.remove(p.mesh); p.mesh.geometry.dispose(); p.mesh.material.dispose(); state.particles.splice(i, 1); }
}
const totalSegs = state.tailSegments.length;
state.tailSegments.forEach((seg, idx) => {
const age = now - seg.time;
const ageRatio = Math.max(0, 1 - age / 5000);
const bodyRatio = totalSegs > 1 ? idx / (totalSegs - 1) : 1;
const scale = 0.5 + bodyRatio * 0.6;
seg.mesh.scale.setScalar(scale);
seg.mesh.material.opacity = (0.2 + bodyRatio * 0.6) * ageRatio;
});
if (state.screenShake > 0) {
state.screenShake *= 0.9;
camera.position.x = (Math.random() - 0.5) * state.screenShake;
camera.position.y = (Math.random() - 0.5) * state.screenShake;
if (state.screenShake < 0.01) { state.screenShake = 0; camera.position.x = 0; camera.position.y = 0; }
}
}
renderer.render(scene, camera);
}
function dropTailSegment(now) {
const interval = 100;
if (now - state.lastTailDropTime < interval) return;
state.lastTailDropTime = now;
const c = config();
const nodeMat = new THREE.MeshBasicMaterial({ color: c.accentHex, transparent: true, opacity: 0.8 });
const node = new THREE.Mesh(tailSegGeo, nodeMat);
const localPos = headGroup.position.clone();
worldGroup.worldToLocal(localPos);
node.position.copy(localPos);
tailGroup.add(node);
const maxLen = c.tailGrow ? (8 + state.revealedIndices.length * 4) : 12;
while (state.tailSegments.length > maxLen) {
const old = state.tailSegments.shift();
tailGroup.remove(old.mesh);
old.mesh.geometry.dispose();
old.mesh.material.dispose();
}
state.tailSegments.push({ mesh: node, time: now });
}
function checkCollisions() {
const headPos = headGroup.position;
const foodWorldPos = new THREE.Vector3();
foodCore.getWorldPosition(foodWorldPos);
if (foodWorldPos.distanceTo(headPos) < 1.5) eatFood();
for (const obs of obstacleGroup.children) {
const p = new THREE.Vector3();
obs.getWorldPosition(p);
if (p.distanceTo(headPos) < 1.1) { gameOver(); return; }
}
}
function eatFood() {
const word = config().word;
const unrevealed = [];
for (let i = 0; i < word.length; i++) { if (!state.revealedIndices.includes(i)) unrevealed.push(i); }
if (unrevealed.length === 0) return;
const idx = unrevealed[Math.floor(Math.random() * unrevealed.length)];
state.revealedIndices.push(idx);
const now = performance.now();
if (now - state.lastEatTime < 4000) { state.combo = Math.min(state.combo + 1, 5); } else { state.combo = 1; }
state.lastEatTime = now;
const points = 100 * state.combo;
state.score += points;
sfxEat();
screenFlash(config().accent, 150);
const foodWorldPos = new THREE.Vector3();
foodCore.getWorldPosition(foodWorldPos);
spawnParticles(foodWorldPos, config().foodColor, 15);
headCore.scale.setScalar(1.4);
headGlow.scale.setScalar(1.8);
setTimeout(() => { headCore.scale.setScalar(1); }, 200);
if (state.combo > 1) { showCombo(`${state.combo}x COMBO +${points}`, config().accent); } else { showCombo(`+${points}`); }
updateHUD();
spawnFood();
if (state.revealedIndices.length === word.length) {
showCombo('SOLVED!', '#ffffff');
state.isPlaying = false;
sfxSolve
